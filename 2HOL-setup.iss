; Script generated by the Inno Setup Script Wizard.
; SEE THE DOCUMENTATION FOR DETAILS ON CREATING INNO SETUP SCRIPT FILES!

#define AppName "Two Hours One Life"
#define AppPublisher "Two Hours One Life Community"
#define WebsiteURL "https://twohoursonelife.com/"
#define DiscordURL "https://discord.com/invite/twohoursonelife"
#define MainExeName "OneLife.exe"
#define MainFolder "2HOL"

[Setup]
; NOTE: The value of AppId uniquely identifies this application. Do not use the same AppId value in installers for other applications.
; (To generate a new GUID, click Tools | Generate GUID inside the IDE.)
AppId={{7E08BD66-E46B-485D-A8B0-1C9E98B3E23D}
AppName={#AppName}
AppVerName={#AppName}
AppPublisher={#AppPublisher}
AppPublisherURL={#WebsiteURL}
AppSupportURL={#WebsiteURL}
AppUpdatesURL={#WebsiteURL}
DefaultDirName={autopf}\{#MainFolder}
DisableDirPage=auto
UninstallDisplayIcon={app}\icon.ico
; Game will run on both x64 and x86 systems so just comment this and it defaults to what we want
; ArchitecturesAllowed=x64compatible
; ArchitecturesInstallIn64BitMode=x64compatible
DisableProgramGroupPage=yes
PrivilegesRequiredOverridesAllowed=dialog
OutputBaseFilename=2HOL-setup
SetupIconFile=icon.ico
SolidCompression=yes
WizardStyle=modern
WizardResizable=no
DisableWelcomePage=no
WizardImageFile=background.bmp

[Languages]
Name: "english"; MessagesFile: "compiler:Default.isl"

[Code]
#include "JsonParser.pas"

var
  OutputFile: String;
  GameFolder: String;
  GameVersions: TArrayOfString;
var
  DownloadPage: TDownloadWizardPage;
  ExtractProgressPage: TOutputProgressWizardPage;
  CustomUninstallForm: TSetupForm;
  UninstallShouldProceed: Boolean;
  UninstallVersionCheckBoxes: array of TNewCheckBox;
  
function OnDownloadProgress(const Url, FileName: String; const Progress, ProgressMax: Int64): Boolean;
begin
  if Progress = ProgressMax then
    Log(Format('Successfully downloaded file to {tmp}: %s', [FileName]));
  Result := True;
end;

procedure OpenDiscordLink(Sender: TObject);
var
    ErrCode: integer;
begin
  ShellExec('open', '{#DiscordURL}', '', '', SW_SHOW, ewNoWait, ErrCode);
end;
  
procedure InitializeWizard;
var
  SubLabel: TLabel;
  InfoLabel: TLabel;
  DiscordLink: TNewStaticText;
begin
  DownloadPage := CreateDownloadPage(SetupMessage(msgWizardPreparing), SetupMessage(msgPreparingDesc), @OnDownloadProgress);
  ExtractProgressPage := CreateOutputProgressPage('Extracting Game Files', 'Please wait while the game files are extracted...');
  
  // Title for welcome page
  WizardForm.WelcomeLabel1.Caption := 'Welcome to Two Hours One Life!';
  WizardForm.WelcomeLabel2.Visible := False;

  // Subtitle for welcome page
  SubLabel := TLabel.Create(WizardForm);
  SubLabel.Parent := WizardForm.WelcomePage;
  SubLabel.AutoSize := True;
  SubLabel.WordWrap := True;
  SubLabel.Top := 75;
  SubLabel.Font.Size := 9;
  SubLabel.Font.Style := [fsBold];
  SubLabel.Caption := 'Required steps to play Two Hours One Life:';
  
  // Instructions in welcome page
  InfoLabel := TLabel.Create(WizardForm);
  InfoLabel.Parent := WizardForm.WelcomePage;
  InfoLabel.AutoSize := True;
  InfoLabel.WordWrap := True;
  InfoLabel.Top := 100;
  InfoLabel.Font.Size := 9;
  InfoLabel.Caption :=
    'â—† Join the Discord server for the game' + #13#10 +
    'â—† Accept the server rules' + #13#10 +
    'â—† A Discord bot will send you your login credentials' + #13#10#13#10 +
    'Missed the message? Just type "/account" in any channel in the server.' + #13#10#13#10 +
    'Note: Youâ€™ll need a Discord account. Click the link to sign up and get started.';
  
  // Create discord link in welcome page
  DiscordLink := TNewStaticText.Create(WizardForm);
  DiscordLink.Parent := WizardForm.WelcomePage;
  DiscordLink.Caption := '  â–¶ Join The Discord Server For Your Login Info';
  DiscordLink.AutoSize := True;
  DiscordLink.Cursor := crHand;
  DiscordLink.Font.Color := clNavy
  DiscordLink.Font.Size := 11;
  DiscordLink.Font.Style := [fsBold];
  DiscordLink.Top := WizardForm.Height - 75;
  DiscordLink.OnClick := @OpenDiscordLink;
end;
  
function GetJsonRoot(Output: TJsonParserOutput): TJsonObject;
begin
  Result := Output.Objects[0];
end;

function FindJsonValue(Output: TJsonParserOutput; Parent: TJsonObject; Key: TJsonString; var Value: TJsonValue): Boolean;
var
  I: Integer;
begin
  for I := 0 to Length(Parent) - 1 do
  begin
    if Parent[I].Key = Key then
    begin
      Value := Parent[I].Value;
      Result := True;
      Exit;
    end;
  end;

  Result := False;
end;

function FindJsonString(Output: TJsonParserOutput; Parent: TJsonObject; Key: TJsonString; var Str: TJsonString): Boolean;
var
  JsonValue: TJsonValue;
begin
  Result :=
    FindJsonValue(Output, Parent, Key, JsonValue) and
    (JsonValue.Kind = JVKString);
  if Result then
  begin
    Str := Output.Strings[JsonValue.Index];
  end;
end;

function ParseJsonAndLogErrors(var JsonParser: TJsonParser; const Source: WideString): Boolean;
var
  I: Integer;
begin
  ParseJson(JsonParser, Source);

  Result := (Length(JsonParser.Output.Errors) = 0);
  if not Result then
  begin
    Log('Error parsing JSON');
    for I := 0 to Length(JsonParser.Output.Errors) - 1 do
    begin
      Log(JsonParser.Output.Errors[I]);
    end;
  end;
end;

function GetExtractProgress(FilePath: String): Integer;
var
  LineCount: Integer;
  Lines: TArrayOfString;
  LastLine: String;
  PosOfPercent: Integer;
begin
  Result := 0;
  if LoadStringsFromLockedFile(FilePath, Lines) then
  begin
    LineCount := GetArrayLength(Lines);
    if LineCount <> 0 then
    begin
      LastLine := Lines[LineCount - 1];
      PosOfPercent := Pos('%', LastLine);
      
      if PosOfPercent > 1 then
      begin
        Result := StrToIntDef(Copy(LastLine, 1, PosOfPercent - 1), 0);
      end;
    
      if (Pos('Everything is Ok', LastLine) = 1) or (Pos('Compressed:', LastLine) = 1) then
      begin
        Result := 100;
      end;
    end;
  end;
end;

// extracts version number from 2HOL_win_v{NUMBER}.zip
function ExtractVersionNumber(const FileName: String): String;
var
  StartPos, EndPos: Integer;
begin
  Result := '';
  StartPos := Pos('_v', FileName);
  if StartPos = 0 then Exit;

  StartPos := StartPos + 2;
  EndPos := Pos('.zip', FileName);
  if EndPos = 0 then Exit;

  Result := Copy(FileName, StartPos, EndPos - StartPos);
end;

// get either the name of the file for the last release or the link
function GetLastestRelease(Mode: String): String;
var
  JsonParser: TJsonParser;
  JsonRoot: TJsonObject;
  JsonValue: TJsonValue;
  AssetsArrayIndex: Integer;
  AssetObj: TJsonObject;
  AssetName, DownloadUrl: TJsonString;
  I: Integer;
  JsonAnsi: AnsiString;
  JsonString: String;
begin
  Result := '';  // default if nothing found

  // load & parse JSON
  if not LoadStringFromFile(ExpandConstant('{tmp}\latest.json'), JsonAnsi) then
    RaiseException('Failed to read latest.json');
  JsonString := JsonAnsi;

  if not ParseJsonAndLogErrors(JsonParser, JsonString) then
    RaiseException('JSON parse failed');
  JsonRoot := GetJsonRoot(JsonParser.Output);

  // grab the assets array
  if not FindJsonValue(JsonParser.Output, JsonRoot, 'assets', JsonValue) then
    RaiseException('"assets" key not found');
  if JsonValue.Kind <> JVKArray then
    RaiseException('"assets" is not an array');

  AssetsArrayIndex := JsonValue.Index;

  // scan for the right asset
  for I := 0 to Length(JsonParser.Output.Arrays[AssetsArrayIndex]) - 1 do
  begin
    JsonValue := JsonParser.Output.Arrays[AssetsArrayIndex][I];
    if JsonValue.Kind <> JVKObject then 
      Continue;

    AssetObj := JsonParser.Output.Objects[JsonValue.Index];

    if FindJsonString(JsonParser.Output, AssetObj, 'name', AssetName) and
       (Pos('2HOL_win_v', AssetName) > 0) and
       FindJsonString(JsonParser.Output, AssetObj, 'browser_download_url', DownloadUrl) then
    begin
      Log('âœ… Found file: ' + AssetName);
      Log('ðŸ”— URL: ' + DownloadUrl);
      if Mode = 'filename' then begin
        Result := AssetName
      end else
        Result := DownloadUrl;
      Exit;
    end;
  end;

  ClearJsonParser(JsonParser);
end;

procedure ShowProgressPageAndResolve;
var
  ExtractProgress: Integer;
begin
  ExtractProgressPage.Show;
  ExtractProgressPage.SetProgress(0, 100);

  repeat
    ExtractProgress := GetExtractProgress(OutputFile);
    Log('Extract progress: ' + IntToStr(ExtractProgress) + '%');
    ExtractProgressPage.SetProgress(ExtractProgress, 100);
    Sleep(500);
  until ExtractProgress >= 100;
  
  DeleteFile(ExpandConstant('{tmp}\') + GetLastestRelease('filename'));
  DeleteFile(OutputFile);

  ExtractProgressPage.Hide;
end;

function GetInstalledGameVersions(): TArrayOfString;
var
  F: TFindRec;
  R: TArrayOfString;
  I: Integer;
begin
  I := 0;
  if FindFirst(ExpandConstant('{app}\*'), F) then
  try
    repeat
      if (F.Attributes and FILE_ATTRIBUTE_DIRECTORY <> 0) and
         (F.Name <> '.') and (F.Name <> '..') and
         (Pos('2HOL_v', F.Name) = 1) then
      begin
        SetArrayLength(R, I + 1);
        R[I] := F.Name;
        I := I + 1;
      end;
    until not FindNext(F);
  finally
    FindClose(F);
  end;
  Result := R;
end;

// this returns not the installing folder but the inner folder the game binary is located
function InstallVersionFolder(Param: String): String;
begin
  if GameFolder = '' then
    GameFolder := '2HOL_v' + ExtractVersionNumber(GetLastestRelease('filename')) + '_win';
  Result := GameFolder;
end;

procedure SaveInstalledVersion;
begin
  SaveStringToFile(ExpandConstant('{app}\last_installed.txt'), InstallVersionFolder(''), False);
end;

function LastInstalledVersion: String;
var
  lastInstalled: AnsiString;
begin
  if LoadStringFromFile(ExpandConstant('{app}\last_installed.txt'), lastInstalled) then begin
    Result := lastInstalled;
  end else
    Result := '';
end;

procedure AddCheckbox(Caption: String; Checked: Boolean; TopPos: Integer);
var
  CheckBox: TNewCheckBox;
begin
  SetLength(UninstallVersionCheckBoxes, Length(UninstallVersionCheckBoxes) + 1);
  CheckBox := TNewCheckBox.Create(CustomUninstallForm);
  CheckBox.Parent := CustomUninstallForm;
  CheckBox.Top := TopPos;
  CheckBox.Left := 50;
  CheckBox.Caption := Caption;
  CheckBox.Width := 150;
  CheckBox.Checked := Checked;
  UninstallVersionCheckBoxes[High(UninstallVersionCheckBoxes)] := CheckBox;
end;

function ShouldSkipPage(PageID: Integer): Boolean;
begin
  // will skip folder selection if user is not installing as admin
  if PageID = wpSelectDir then
    if not IsAdminInstallMode then
      Result := True; 
end;

function NextButtonClick(CurPageID: Integer): Boolean;
var
  lastIndex: Integer;
begin
  if CurPageID = wpReady then begin  
    DownloadPage.Clear;
    DownloadPage.Add('https://api.github.com/repos/twohoursonelife/OneLife/releases/latest', 'latest.json', '');
    DownloadPage.Show;
    try
      DownloadPage.Download;
      
      DownloadPage.Clear;
      DownloadPage.Add(GetLastestRelease('link'), '2HOL-latest.zip', '');
      DownloadPage.Show;
      try
        if not (LastInstalledVersion = InstallVersionFolder('')) then
          // only download the game if the last installed version is not equal to the lastest version
          DownloadPage.Download;
      except
        SuppressibleMsgBox(AddPeriod(GetExceptionMessage), mbCriticalError, MB_OK, IDOK);
        Result := False;
      end;

      Result := True;
    except
      SuppressibleMsgBox(AddPeriod(GetExceptionMessage), mbCriticalError, MB_OK, IDOK);
      Result := False;
    finally
      DownloadPage.Hide;
    end;
  end else
    Result := True;
end;

procedure CurStepChanged(CurStep: TSetupStep);
var
  ResultCode: Integer;
  Cmd: String;
  ExtractProgress: Integer;
begin
  if CurStep = ssInstall then
  begin
    if not FileExists(ExpandConstant('{tmp}\2HOL-latest.zip')) then
    begin
      // if 2HOL-latest.zip doesn't exist it may mean the download was skipped because this version is already installed
      Log(ExpandConstant('{app}\') + InstallVersionFolder(''));
      if DirExists(ExpandConstant('{app}\') + InstallVersionFolder('')) then begin
        MsgBox('Lastest game version already installed.', mbInformation, MB_OK);
      end else 
        MsgBox('The game was not properly downloaded and will not be installed.', mbInformation, MB_OK);
      Exit;
    end;
    
    OutputFile := ExpandConstant('{tmp}\extraction_progress.txt');
    DeleteFile(OutputFile);
    ExtractTemporaryFile('7za.exe');
    Cmd := '/C "' + ExpandConstant('{tmp}\7za.exe') + ' -bsp1 x "' + ExpandConstant('{tmp}\2HOL-latest.zip') + '" -o"' + ExpandConstant('{app}') + '" -aos' + ' > "' + OutputFile + '"';
    
    // this runs 7zip extraction asynchronously while saving progress to file
    if Exec('cmd.exe', Cmd, '', SW_HIDE, ewNoWait, ResultCode) then
    begin
      Log('Extracting game...');
    end;
    ExtractProgress := 0;
    
    ShowProgressPageAndResolve; // this will read the progress file that's being written asynchronously
    SaveInstalledVersion;
  end;
end;

procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep);
var
  index: Integer;
  dirToDelete: String;
  numberDeleted: Integer;
begin
  if CurUninstallStep = usPostUninstall then
  begin
    numberDeleted := 0;
    // find all checkboxes that are checked
    for index := 0 to GetArrayLength(UninstallVersionCheckBoxes) - 1 do
    begin
      if (UninstallVersionCheckBoxes[index].Checked = True) and (Pos('2HOL_v', UninstallVersionCheckBoxes[index].Caption) = 1) then
        // DANGEROUS, DELETE GAME VERSIONS RECURSIVELY
        dirToDelete := ExpandConstant('{app}\') + UninstallVersionCheckBoxes[index].Caption;
        if (DirExists(dirToDelete)) then
        begin
          Log('Deleting: ' + dirToDelete);
          DelTree(dirToDelete, True, True, True);
          Inc(numberDeleted);
        end;
    end;
  end;
end;

procedure NextFormButtonClick(Sender: TObject);
begin
  UninstallShouldProceed := True;
  CustomUninstallForm.Close;
end;

function InitializeUninstall(): Boolean;
var
  lastIndex: Integer;
  NewLabel: TLabel;
  NextButton: TNewButton;
begin
  UninstallShouldProceed := False;
  
  CustomUninstallForm := CreateCustomForm;
  CustomUninstallForm.Caption := 'Uninstall Game Versions';
  CustomUninstallForm.Width := 300;
  CustomUninstallForm.Height := 150;
  CustomUninstallForm.Position := poScreenCenter;

  NewLabel := TLabel.Create(CustomUninstallForm);
  NewLabel.Parent := CustomUninstallForm;
  NewLabel.Caption := 'Choose the versions you wish to uninstall:';
  NewLabel.Top := 10;
  NewLabel.Left := 40;

  GameVersions := GetInstalledGameVersions();
  for lastIndex := 0 to GetArrayLength(GameVersions) - 1 do
  begin
    // add checkboxes one below another
    AddCheckbox(GameVersions[lastIndex], True, 35 + (lastIndex*20));
  end;
  //dinamically change the window height depending on the number of elements
  CustomUninstallForm.Height := CustomUninstallForm.Height + (lastIndex*20) - 20;

  NextButton := TNewButton.Create(CustomUninstallForm);
  NextButton.Parent := CustomUninstallForm;
  NextButton.Caption := 'Next';
  NextButton.Top := 50 + (lastIndex*20);
  NextButton.Width := 100;
  NextButton.Left := (CustomUninstallForm.ClientWidth - NextButton.Width) div 2;
  NextButton.OnClick := @NextFormButtonClick;

  CustomUninstallForm.ShowModal;
  
  // Don't proceed unless user clicked next on the form
  begin
    if UninstallShouldProceed then begin
      Result := True
    end else
      Result := False;
  end;
end;

[Files]
; Temporary Files
Source: "{tmp}\latest.json"; DestDir: "{tmp}"; Flags: external deleteafterinstall
Source: "7zip\7za.exe"; DestDir: "{tmp}"; Flags: dontcopy
Source: "background.bmp"; DestDir: "{tmp}"; Flags: dontcopy
; Permanent Files
Source: "icon.ico"; DestDir: "{app}"
Source: "twotech.ico"; DestDir: "{app}"

[UninstallDelete]
; If this file is deleted it will override on next installation if set on same folder
Type: files; Name: "{app}\last_installed.txt"

[Icons]
Name: "{autoprograms}\{#AppName}"; Filename: "{app}\{code:InstallVersionFolder}\{#MainExeName}"; IconFilename: "{app}\icon.ico"
Name: "{autodesktop}\{#AppName}"; Filename: "{app}\{code:InstallVersionFolder}\{#MainExeName}"; IconFilename: "{app}\icon.ico"
Name: "{autodesktop}\TwoTech - Crafting Reference"; Filename: "https://twotech.twohoursonelife.com/"; IconFilename: "{app}\twotech.ico"; IconIndex: 0

[Run]
Filename: "{#WebsiteURL}"; Flags: shellexec postinstall runmaximized; Description: "Open 2HOL's Website"
Filename: "{#DiscordURL}"; Flags: shellexec postinstall runmaximized; Description: "Open Discord Server for account info and help"
Filename: "{app}\{code:InstallVersionFolder}\{#MainExeName}"; Description: "{cm:LaunchProgram,{#StringChange('Two Hours One Life', '&', '&&')}}"; Flags: nowait postinstall skipifsilent
